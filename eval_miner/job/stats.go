package job

import (
	"eval_miner/log"
)

type GetworkStats struct {
	Calls         int
	Wait          float64
	WaitMax       float64
	WaitMin       float64
	Getworks      int // number of notify messages received in Stratum's case
	LocalWork     int // number of jobs created in total, including ones from Stratum and generated by SW (rolling NTime or Version or ExtraNonce2)
	LastGetworkTS float64
	GetFailures   int
}

func UpdateGetwork(GS *GetworkStats, tdiff float64, getworkTS float64, getworks int) {
	GS.Calls++
	GS.Wait += tdiff
	if GS.WaitMax < tdiff {
		GS.WaitMax = tdiff
	}
	if GS.WaitMin > tdiff {
		GS.WaitMin = tdiff
	}
	GS.Getworks = getworks
	GS.LocalWork = getworks
}

type ShareStats struct {
	Accepted          int
	Rejected          int
	DiffAccepted      float64
	DiffRejected      float64
	LastSharePool     uint
	LastShareDiff     float64
	LastShareUpdateTS float64
	BestShare         uint64
	Utility           float64
	RemoteFailures    int
}

func UpdateShares(SS *ShareStats, bAccepted bool, diffSubmit uint64, tsInSec float64) {
	if bAccepted {
		SS.Accepted++
		SS.DiffAccepted += float64(diffSubmit)
		SS.LastShareDiff = float64(diffSubmit)
		SS.LastShareUpdateTS = tsInSec
	} else {
		SS.Rejected++
		SS.DiffRejected += float64(diffSubmit)
	}

	if diffSubmit > SS.BestShare {
		SS.BestShare = diffSubmit
	}

}

func UpdateRemoteFailures(SS *ShareStats, nRemoteFailures int) {
	SS.RemoteFailures += nRemoteFailures
}

func UpdateUtility(SS *ShareStats, UptimeInSeconds float64) {
	if UptimeInSeconds < 1.0 {
		UptimeInSeconds = 1.0
	}
	SS.Utility = float64(SS.Accepted) / UptimeInSeconds * 60
}

type HashStats struct {
	MHSav           float64
	MHS5s           float64
	MHS1m           float64
	MHS5m           float64
	MHS15m          float64
	MHS24h          float64
	TotalMHash      float64
	MaxHashes       uint64
	UpdateTS        float64 // Update TS is initilized to start time
	UpdateTSnz      float64 // last non-zero update TS
	LastValidWorkTS float64 // LastValidWork TS is initialized to zero
	HWErrors        uint64
	HWHits          uint64
	Stale           uint64
	DiffStale       float64
	Discarded       int
}

func updateHashRate(OldHashRate float64, dtOld float64, NewHashDone uint64, ts float64, HS *HashStats) float64 {
	// time diff in seconds
	dtNew := ts - HS.UpdateTS

	// pulling too frequent
	if ts == HS.UpdateTS {
		return OldHashRate
	}

	// this should only happen for initialization
	if ts < HS.UpdateTS {
		log.Errorf("Old TS %v, New TS %v", HS.UpdateTS, ts)
		dtNew = 1.0 // 1 second
	}

	if dtNew >= dtOld {
		return float64(NewHashDone) / dtNew
	}

	// HashDone is 0 for a long time, more than dtOld
	if NewHashDone == 0 && ts > HS.UpdateTSnz+dtOld {
		return 0
	}

	NewHashRate := (OldHashRate*float64(dtOld-dtNew) + float64(NewHashDone)) / float64(dtOld)
	return NewHashRate
}

// ts is unix time in seconds with precision to microseconds
func UpdateHashes(HS *HashStats, HashDone uint64, ts float64, uptime float64) {

	if HS.MaxHashes < HashDone {
		HS.MaxHashes = HashDone
	}

	// meatured in MHS
	MHashDone := HashDone / 1000000

	HS.MHS5s = updateHashRate(HS.MHS5s, 5, MHashDone, ts, HS)
	HS.MHS1m = updateHashRate(HS.MHS1m, 1*60, MHashDone, ts, HS)
	HS.MHS5m = updateHashRate(HS.MHS5m, 5*60, MHashDone, ts, HS)
	HS.MHS15m = updateHashRate(HS.MHS15m, 15*60, MHashDone, ts, HS)
	HS.MHS24h = updateHashRate(HS.MHS24h, 24*60*60, MHashDone, ts, HS)

	HS.TotalMHash += float64(MHashDone)

	if uptime == 0 {
		uptime = 1.0
	}
	HS.MHSav = HS.TotalMHash / uptime

	HS.LastValidWorkTS = ts

	HS.UpdateTS = ts
	if HashDone != 0 {
		HS.UpdateTSnz = ts
	}
}

// ts is unix time in seconds with precision to microseconds
func UpdateStale(HS *HashStats, diffSubmit uint64) {
	HS.Stale++
	HS.DiffStale += float64(diffSubmit)
}

type DiffStats struct {
	MinDiff      float64
	MaxDiff      float64
	LastDiff     float64
	MinDiffCount int
	MaxDiffCount int
	Diff1        uint64
	WorkUtility  float64
}

func UpdateDiffs(DS *DiffStats, diffTarget float64, DevDiff uint64, uptime float64) {
	DS.LastDiff = diffTarget

	if diffTarget == DS.MinDiff {
		DS.MinDiffCount++
	} else if diffTarget < DS.MinDiff || DS.MinDiff == 0 {
		DS.MinDiff = diffTarget
		DS.MinDiffCount = 1
	}

	if diffTarget == DS.MaxDiff {
		DS.MaxDiffCount++
	} else if diffTarget > DS.MaxDiff {
		DS.MaxDiff = diffTarget
		DS.MaxDiffCount = 1
	}

	DS.Diff1 += DevDiff

	if uptime == 0 {
		uptime = 1.0
	}
	DS.WorkUtility = float64(DS.Diff1) / uptime
}

type ByteStats struct {
	N     uint64
	Bytes uint64
}

func UpdateBytes(To *ByteStats, From ByteStats) {
	To.Bytes += From.Bytes
	To.N += From.N
}

type StatsFunc struct {
	ShareFunc         func(bAccepted bool, J *Job)
	DiffFunc          func(J *Job)
	BytesFunc         func(IsRecv bool, bytes ByteStats)
	HashFunc          func(HashDone uint64, GeneralHitDone uint64, J *Job)
	DiscardFunc       func(nDiscarded int)
	RemoteFailureFunc func(nRemoteFailures int)
}
